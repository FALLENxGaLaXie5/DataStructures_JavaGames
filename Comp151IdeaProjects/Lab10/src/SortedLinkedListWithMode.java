/** * A class that implements the ADT sorted list by using a chain of linked nodes. * Duplicate entries are allowed. * * @author Joshua Steward * @author Frank M. Carrano * @version 3/28/2015 */public class SortedLinkedListWithMode<T extends Comparable<? super T>>{    private Node firstNode; // reference to first node of chain    private int numberOfEntries;    public SortedLinkedListWithMode()    {        this.firstNode = null;        this.numberOfEntries = 0;    } // end default constructor    // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv    /**     * sets the mostFrequent Integer to null     * if myList contains entries     *      set currentNode to firstNode     *      set nextNode to currentNode     *      set the mostFrequent to data in currentNode     *      set currentCount to 1     *      set currentHighestCount to currentCount     *      for every entries of mylist, from the 2nd entry to the end     *          set nextNode to the next link from nextNode     *          if nextNode's data is equal to currentNode's data     *              increment currentCount     *          otherwise,     *              set currentCount to 1 and currentNode to nextNode     *                  if currentCount is greater than currentHighestCount     *                      set currentHighestCount to currentCount     *          if the currentcount is greater than the currentHighestCount     *              set currenthighestCount to currentCount     *              set mostFrequent to data in nextNode     *     * @return  mostFrequent (mode)     */    public T getMode()    {        T mostFrequent = null;        if (this.numberOfEntries > 0)        {            Node currentNode = this.firstNode;            Node nextNode = currentNode;            mostFrequent = currentNode.data;            int currentCount = 1;            int currentHighestCount = currentCount;            for (int i = 1; i < this.numberOfEntries; i++)            {                nextNode = nextNode.next;                if (nextNode.data.compareTo(currentNode.data) == 0)                {                    currentCount++;                }                else                {                    currentCount = 1;                    currentNode = nextNode;                    if (currentCount > currentHighestCount)                    {                        currentHighestCount = currentCount;                    }                }                if (currentCount > currentHighestCount)                {                    currentHighestCount = currentCount;                    mostFrequent = nextNode.data;                }            }        }        return mostFrequent;    } // end getMode    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    public void add(T newEntry)    {        Node newNode = new Node(newEntry);        Node nodeBefore = getNodeBefore(newEntry);        if (isEmpty() || (nodeBefore == null)) // add at beginning        {            newNode.setNextNode(this.firstNode);            this.firstNode = newNode;        } else                                   // add after nodeBefore        {            Node nodeAfter = nodeBefore.getNextNode();            newNode.setNextNode(nodeAfter);            nodeBefore.setNextNode(newNode);        } // end if        this.numberOfEntries++;    } // end add    /**     * Finds the node that is before the node that     * should or does contain a given entry.     *     * @param anEntry the object to be located     * @return either a reference to the node that is before the node     *         that contains or should contain anEntry, or null if     *         no prior node exists (that is, if anEntry belongs at     *         the beginning of the list)     */    private Node getNodeBefore(T anEntry)    {        Node currentNode = this.firstNode;        Node nodeBefore = null;        while ((currentNode != null) &&                (anEntry.compareTo(currentNode.getData()) > 0))        {            nodeBefore = currentNode;            currentNode = currentNode.getNextNode();        } // end while        return nodeBefore;    } // end getNodeBefore    public boolean remove(T anEntry)    {        boolean found = false;        if (this.numberOfEntries > 0)        {            Node nodeToRemove;            Node nodeBefore = getNodeBefore(anEntry);            if (nodeBefore == null)                nodeToRemove = this.firstNode;            else                nodeToRemove = nodeBefore.getNextNode();            if ((nodeToRemove != null) && anEntry.equals(nodeToRemove.getData()))            {                found = true;                if (nodeBefore == null)                    this.firstNode = nodeToRemove.getNextNode();                else                {                    Node nodeAfter = nodeToRemove.getNextNode();                    nodeBefore.setNextNode(nodeAfter);                } // end if                this.numberOfEntries--;            } // end if        } // end if        return found;    } // end remove    public int getPosition(T anEntry)    {        int position = 1;        Node currentNode = this.firstNode;        while ((currentNode != null) && (anEntry.compareTo(currentNode.getData()) > 0))        {            currentNode = currentNode.getNextNode();            position++;        } // end while        if ((currentNode == null) || anEntry.compareTo(currentNode.getData()) != 0)            position = -position;        return position;    } // end getPosition    // list operations    public T remove(int givenPosition)    {        T result = null;                           // return value        if ((givenPosition >= 1) && (givenPosition <= this.numberOfEntries))        {            assert !isEmpty();            if (givenPosition == 1)                 // case 1: remove first entry            {                result = this.firstNode.getData();        // save entry to be removed                this.firstNode = this.firstNode.getNextNode();            } else                                    // case 2: givenPosition > 1            {                Node nodeBefore = getNodeAt(givenPosition - 1);                Node nodeToRemove = nodeBefore.getNextNode();                Node nodeAfter = nodeToRemove.getNextNode();                nodeBefore.setNextNode(nodeAfter);   // disconnect the node to be removed                result = nodeToRemove.getData();     // save entry to be removed            } // end if            this.numberOfEntries--;        } // end if        return result;                             // return removed entry, or        // null if operation fails    } // end remove    public final void clear()    {        this.firstNode = null;        this.numberOfEntries = 0;    } // end clear    public T getEntry(int givenPosition)    {        T result = null;  // result to return        if ((givenPosition >= 1) && (givenPosition <= this.numberOfEntries))        {            assert !isEmpty();            result = getNodeAt(givenPosition).getData();        } // end if        return result;    } // end getEntry    public boolean contains(T anEntry)    {        boolean found = false;        Node currentNode = this.firstNode;        while (!found && (currentNode != null))        {            if (anEntry.equals(currentNode.getData()))                found = true;            else                currentNode = currentNode.getNextNode();        } // end while        return found;    } // end contains    public int getLength()    {        return this.numberOfEntries;    } // end getLength    public boolean isEmpty()    {        boolean result;        if (this.numberOfEntries == 0) // or getLength() == 0        {            assert this.firstNode == null;            result = true;        } else        {            assert this.firstNode != null;            result = false;        } // end if        return result;    } // end isEmpty    public boolean isFull()    {        return false;    } // end isFull    public T[] toArray()    {        // the cast is safe because the new array contains null entries        @SuppressWarnings("unchecked")        T[] result = (T[]) new Comparable[this.numberOfEntries]; // warning: [unchecked] unchecked cast        int index = 0;        Node currentNode = this.firstNode;        while ((index < this.numberOfEntries) && (currentNode != null))        {            result[index] = currentNode.getData();            currentNode = currentNode.getNextNode();            index++;        } // end while        return result;    } // end toArray    private Node getNodeAt(int givenPosition)    {        assert !isEmpty() && (1 <= givenPosition) && (givenPosition <= this.numberOfEntries);        Node currentNode = this.firstNode;        // traverse the list to locate the desired node        for (int counter = 1; counter < givenPosition; counter++)            currentNode = currentNode.getNextNode();        assert currentNode != null;        return currentNode;    } // end getNodeAt    /**     * displays this.numberOfEntries elements in the list     *     */    public void display()    {        System.out.print("\nThe data has " + this.numberOfEntries + " elements: ");        Node currentNode = this.firstNode;        int index = 0;        while ((index < this.numberOfEntries) && (currentNode != null))        {            System.out.print(currentNode.data + " ");            currentNode = currentNode.next;        }        System.out.println();    }    private class Node    {        private T data; // entry in list        private Node next; // link to next node        private Node(T dataPortion)        {            this.data = dataPortion;            this.next = null;        } // end constructor        private Node(T dataPortion, Node nextNode)        {            this.data = dataPortion;            this.next = nextNode;        } // end constructor        private T getData()        {            return this.data;        } // end getData        private void setData(T newData)        {            this.data = newData;        } // end setData        private Node getNextNode()        {            return this.next;        } // end getNextNode        private void setNextNode(Node nextNode)        {            this.next = nextNode;        } // end setNextNode    } // end Node    public static void main(String args[])    {        SortedLinkedListWithMode<Integer> data = new SortedLinkedListWithMode<Integer>();        for (int i = 0; i < 10; i++)            data.add(i);        data.display();        System.out.println("The mode should be 0, got: " + data.getMode());        for (int i = 0; i < 10; i++)            for (int j = 0; j < i; j++)                data.add(i);        data.display();        System.out.println("The mode should be 9, got: " + data.getMode());        for (int i = 0; i < 21; i++)            for (int j = 8; j < i; j++)                data.add(i);        data.display();        System.out.println("The mode should be 20, got: " + data.getMode());        for (int i = 0; i < 14; i++)            data.add(6);        data.display();        System.out.println("The mode should be 6, got: " + data.getMode());        // test list of 1 element        data = new SortedLinkedListWithMode<Integer>();        data.add(9);        data.display();        System.out.println("The mode should be 9, got: " + data.getMode());    } // end main} // end SortedLinkedList