import java.util.ArrayList;import java.util.List;import java.util.Random;/** * A class that represents a message. * * @author Joshua Steward * @version 3/28/2015 */public class Message{    private String originalMessage;    private int packetLength;    private String retrievedMessage;    private List<Packet> sentPackets;    private List<Packet> receivedPackets;    public final static int SMALLEST_PACKET_LENGTH = 3;    /**     * Constructor sets this.originalMessage to the input given by the user     * sets this.packetLength to the packet length given by the user     *     * @param theMessage     * @param thePacketLength     */    public Message(String theMessage, int thePacketLength)    {        this.originalMessage = theMessage;        this.packetLength = thePacketLength;        this.retrievedMessage = "";        this.sentPackets = new ArrayList<>();        this.receivedPackets = new ArrayList<>();    }    /**     * Breaks the  original message to a collection of packets.     * The created packet objects are saved to this.sentPackets     */    /**     * send()     * instantiates sequenceNumber to 0     * for all i up to the length of the originalMessage, incrementing i by the packetLength     *      if the originalMessage length divided by the packet length is less than 2     *          increment sequenceNumber     *      if the current i + the packetLength is greater than the original message length     *          creates a new Packet with the current sequence number, and portion of     *          originalMessage from i to the original message length     *      else     *          creates a new Packet with the current sequence number and the portion     *          of the original message from the current i to i + the packet length     *          increments sequenceNumber     *      add newPacket to sentPackets arrayList     */    public void send()    {        Packet newPacket;        int sequenceNum = 0;        for (int i = 0; i < this.originalMessage.length(); i+= this.packetLength)        {            if (this.originalMessage.length() / this.packetLength < 2)            {                sequenceNum++;            }            if (i + this.packetLength > this.originalMessage.length())            {                newPacket = new Packet(sequenceNum, this.originalMessage.substring(i, this.originalMessage.length()));            }            else            {                newPacket = new Packet(sequenceNum, this.originalMessage.substring(i, i + this.packetLength));                sequenceNum++;            }            this.sentPackets.add(newPacket);        }           // The content of created packet collection        System.out.println("Sent packets:" + this.sentPackets);    }    /**     * Simulates the receipt of the packets of a message.     * Calls the private shuffle method so the packets     * are not in any particular order. They are saved to this.receivedPackets     */    public void receive()    {        int numberOfPackets = this.sentPackets.size();        this.receivedPackets = new ArrayList<>(this.sentPackets);        // shuffle the packets to simulate their arrival order        shuffle(this.receivedPackets, numberOfPackets);        System.out.println("Received packets:" + this.receivedPackets);    }    public String getOriginalMessage()    {        return this.originalMessage;    }    public String getRetrievedMessage()    {        return this.retrievedMessage;    }    /**     * This is a private method that recursively shuffles the packet     * objects so they are arranged in no particular order     *     * if the numberOfPackets is greater than 1     *      instantiate generator as a new random object     *      set indextoSwap to a random number between 0 and numberOfPackets - 1     *      set tempPacket to the packet at index to swap in packetList     *      set the index at index to swap at the packet at the number of packets - 1 in packetList     *      set the index of numberofPackets - 1 to tempPacket in packetList     *      recursive call with the packet list and number of packets - 1     * @param packetList     * @param numberOfPackets     */    private void shuffle(List<Packet> packetList, int numberOfPackets)    {        if (numberOfPackets > 1)        {            // swap packet at index numberOfPackets - 1 and a random index            Random generator = new Random();            int indexToSwap = generator.nextInt(numberOfPackets - 1);            Packet tempPacket = packetList.get(indexToSwap);            packetList.set(indexToSwap, packetList.get(numberOfPackets - 1));            packetList.set(numberOfPackets - 1, tempPacket);            shuffle(packetList, numberOfPackets - 1);        }    }    /**     *   Constructs the message back and saves it in this.retrievedMessage     *   utilizes SortedLinkedList to arrange the packet objects according     *   to their sequence number     */    /**     * set messageBuilder to new StringBuilder     * set sortedMessage to new SortedLinkedList     *     * for each packet in receivedPackets     *      add currentPacket to sortedMessage, where it is put in correct sorted spot     * for the number of elements in sortedMessage     *      append the packet message of sortedMessage at position i to messageBuilder     * set retrievedMessage to the string of messageBuilder     */    public void assemble()    {        StringBuilder messageBuilder = new StringBuilder();        SortedListInterface<Packet> sortedMessage = new SortedLinkedList<>();        // add packets to the sorted list        for (Packet currentPacket : this.receivedPackets)        {            sortedMessage.add(currentPacket);        }        for (int i = 1; i <= sortedMessage.getLength(); i++)        {            messageBuilder.append(sortedMessage.getEntry(i).getPacketMessage());        }        this.retrievedMessage = messageBuilder.toString();        // put pieces of message together        // set this.retrievedMessage to the reconstructed string    }}